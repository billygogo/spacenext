{
  "rules": [
    {
      "type": "prd",
      "content": "\n\n# ✅ Product Requirements Document – space.NEXT 단일 회의실 예약 웹서비스\n\n## 1. Executive Summary\n\n**space.NEXT**는 단 하나의 독립된 회의실과 라운지를 운영하는 프라이빗 공간입니다. 사용자는 웹을 통해 간편하게 원하는 날짜와 시간을 선택해 회의실을 예약하고, 비대면 입장까지 원스톱으로 진행할 수 있습니다. 운영자는 예약 현황을 실시간으로 확인하고, 별도의 연락 없이 공간을 자동으로 운영할 수 있습니다.\n\n---\n\n## 2. Problem Statement\n\n* 기존 오프라인 예약은 DM/전화 등 수동 방식으로 진행되어 운영자가 반복적인 커뮤니케이션에 시간을 낭비함\n* 고객 입장에서도 공간 정보와 예약 가능 시간을 명확히 확인하기 어려움\n* 입장 안내, 결제, 환불 등의 과정이 수동이라 운영 효율이 낮고 노쇼 대응도 어려움\n\n---\n\n## 3. Goals and Objectives\n\n* **Primary Goal**: 웹 기반 예약·결제·입장 안내 시스템을 통해 운영자의 개입 없이도 공간 운영 가능하게 함\n* **Secondary Goals**\n\n  * 90% 이상의 예약 자동화율 확보\n  * 노쇼율 5% 미만으로 유지 (선결제 및 알림 연동)\n  * 예약 완료까지 평균 소요 시간 3분 이내\n\n---\n\n## 4. Target Audience\n\n* **주요 고객**\n\n  * 1인 사업자, 소규모 팀 (3\\~8인)\n  * 고객 상담, 팀 회의, 스터디 등 소규모 집중 모임 수요자\n* **운영자 (관리자)**\n\n  * 공간 하나를 직접 관리·운영하는 호스트 1인\n\n---\n\n## 5. User Stories\n\n* “예약자”로서 날짜와 시간만 선택해 빠르게 회의실을 예약하고 싶다.\n* “예약자”로서 결제 후 입장 방법을 알림톡으로 받고 싶다.\n* “예약자”로서 앱 설치 없이 웹에서 예약 내역을 보고 싶다.\n* “운영자”로서 별도 연락 없이 예약·결제·입장 안내가 자동으로 처리되길 원한다.\n* “운영자”로서 노쇼와 중복 예약이 방지되길 바란다.\n\n---\n\n## 6. Functional Requirements\n\n### Core Features (사용자)\n\n1. **예약 선택**\n\n   * 달력 기반 UI, 시간 단위 선택 (30분 or 1시간 단위)\n   * 예약 가능 여부 실시간 표시\n   * 선택 시 가격 자동 계산\n \n\n2. **예약 확정 및 결제**\n\n   * 카드/간편결제(Stripe 또는 TossPayments)\n   * 결제 완료 시 상태 = \"confirmed\"\n   * 알림톡 또는 이메일로 입장 안내 발송\n   * 환불 정책: 예약 24시간 전까지 100% 환불 가능\n\n3. **예약 내역 확인**\n\n   * 로그인 없이 링크 기반 예약 내역 확인 가능\n   * 예약 취소 버튼 제공 (취소 가능 시간 내)\n\n4. **비대면 입장 안내**\n\n   * QR 또는 도어락 비밀번호 자동 발송\n   * 입장 시각 10분 전 리마인드 알림\n\n---\n\n### Admin Features (운영자)\n\n* 관리자 대시보드: 달력 기반 예약 현황 조회\n* 예약 수동 등록/수정 기능\n* 예약 확정 시 자동으로 입장 안내 전송\n* 운영 시간, 이용 요금, 취소 정책 설정\n\n---\n\n## 7. Non-Functional Requirements\n\n* Performance: 검색/예약 응답 <2초\n* Security: 고객 정보 및 결제 정보 암호화\n* Usability: 모바일 반응형 우선, PC 호환\n* Reliability: 동시 예약 방지 (예약시간 중복 불가)\n\n---\n\n## 8. Technical Considerations\n\n* **Frontend**: Next.js + TypeScript + Tailwind\n* **Backend**: Supabase (PostgreSQL + Auth + Storage)\n* **Payment**: Stripe \n* **Infra**: Vercel + Cloudflare CDN\n* **Notification**: 카카오 알림톡 / 이메일 (예약 안내, 리마인더)\n\n---\n## 9. Success Metrics\n\n* 예약 완료율 > 95%\n* 노쇼율 < 5%\n* 평균 예약 완료 시간 < 3분\n* 운영자 개입 없이 자동 처리 비율 > 90%\n\n---\n\n## 10. Timeline\n\n* **Week 1–2**: UI 기획 및 디자인\n* **Week 3–5**: 예약 시스템 개발 (검색, 선택, 결제)\n* **Week 6–7**: 입장 안내 자동화, 관리자 기능 개발\n* **Week 8**: 테스트 및 배포\n\n---\n\n## 11. Risks and Mitigation\n\n* **위험요소**: 예약 시간 중복 처리 → DB unique 제약조건 적용\n* **노쇼 방지**: 선결제 + 리마인드 알림\n* **입장 오류**: 도어락·QR 코드 전달 자동화 + 수동 대응 백업 프로세스\n\n\n",
      "writedAt": "2025-07-23T07:55:12.875Z"
    },
    {
      "type": "architecture",
      "content": "# 기술 요구사항 문서 (TRD)\n\n## 1. 기술 요약 (Executive Technical Summary)\n\n*   **프로젝트 개요**: space.NEXT는 단일 회의실 및 라운지 예약을 위한 웹 기반 시스템으로, 사용자에게는 간편한 예약 및 비대면 입장을, 운영자에게는 자동화된 공간 관리를 제공합니다. 본 시스템은 운영 개입을 최소화하고 사용자 편의성을 극대화하는 데 중점을 둡니다.\n*   **핵심 기술 스택**: 프론트엔드는 Next.js, TypeScript, Tailwind CSS를 사용하고, 백엔드는 Supabase(PostgreSQL, 인증, 스토리지 포함)를 활용합니다. 결제는 Stripe를 통합하며, 인프라는 Vercel과 Cloudflare CDN을 사용합니다. 알림은 카카오 알림톡 또는 이메일을 통해 발송됩니다.\n*   **주요 기술 목표**:\n    *   예약 및 결제 응답 시간 2초 이내 달성\n    *   고객 및 결제 정보의 강력한 암호화 및 보안 유지\n    *   모바일 우선 반응형 디자인 구현 및 PC 호환성 확보\n    *   동시 예약 방지를 위한 데이터 무결성 보장\n*   **핵심 기술 가정**:\n    *   Supabase는 인증, 데이터베이스, 스토리지 요구사항을 충분히 충족할 수 있습니다.\n    *   Stripe는 결제 처리 및 환불 기능을 안정적으로 제공합니다.\n    *   Vercel과 Cloudflare CDN은 빠른 배포 및 안정적인 서비스 제공을 지원합니다.\n    *   카카오 알림톡 또는 이메일 서비스는 예약 안내 및 리마인더 발송에 적합합니다.\n\n## 2. 기술 스택 (Tech Stack)\n\n| Category | Technology / Library | Reasoning (Why it's chosen for this project) |\n| :------- | :------------------- | :------------------------------------------- |\n| 프론트엔드 | Next.js | SSR/SSG 지원으로 SEO 및 초기 로딩 속도에 유리하며, 파일 기반 라우팅으로 개발 생산성이 높습니다. |\n| 프론트엔드 | TypeScript | 타입 안정성을 제공하여 개발 중 오류를 줄이고 코드 유지보수성을 향상시킵니다. |\n| 프론트엔드 | Tailwind CSS | 유틸리티 우선 CSS 프레임워크로, 빠르고 일관된 UI 개발을 가능하게 합니다. |\n| 백엔드/DB | Supabase | PostgreSQL 기반의 BaaS(Backend as a Service)로, 인증, 데이터베이스, 스토리지 기능을 한 번에 제공하여 개발 속도를 높이고 운영 부담을 줄입니다. |\n| 결제 | Stripe | 글로벌 표준 결제 솔루션으로, 안정적인 결제 처리 및 다양한 결제 수단을 지원합니다. |\n| 인프라 | Vercel | Next.js에 최적화된 배포 플랫폼으로, 빠르고 간편한 CI/CD 및 CDN 통합을 제공합니다. |\n| 인프라 | Cloudflare CDN | Vercel과 연동하여 정적 자산 캐싱 및 보안을 강화하여 서비스 응답 속도를 향상시킵니다. |\n| 알림 | 카카오 알림톡 / 이메일 서비스 | 사용자에게 예약 확정, 입장 안내, 리마인더 등 중요한 정보를 효율적으로 전달하기 위함입니다. (구체적인 서비스는 개발 단계에서 선정) |\n\n## 3. 시스템 아키텍처 설계 (System Architecture Design)\n\n### 최상위 빌딩 블록 (Top-Level building blocks)\n\n*   **클라이언트 (Client)**: 사용자가 직접 상호작용하는 웹 애플리케이션입니다. Next.js로 개발되며, 예약 선택, 결제, 예약 내역 확인 등의 기능을 제공합니다.\n*   **백엔드 API (Backend API)**: 클라이언트의 요청을 처리하고 데이터베이스와 상호작용하는 핵심 로직입니다. Supabase의 API Gateway를 통해 제공됩니다.\n*   **데이터베이스 (Database)**: 모든 예약 정보, 사용자 정보, 공간 설정 등을 저장합니다. Supabase의 PostgreSQL 데이터베이스를 사용합니다.\n*   **인증 서비스 (Authentication Service)**: 사용자 로그인 및 세션 관리를 담당합니다. Supabase Auth를 활용합니다.\n*   **결제 게이트웨이 (Payment Gateway)**: 결제 요청을 처리하고 실제 결제를 수행합니다. Stripe API를 통해 연동됩니다.\n*   **알림 서비스 (Notification Service)**: 예약 확정, 입장 안내, 리마인더 등의 알림을 사용자에게 발송합니다. 카카오 알림톡 또는 이메일 발송 API를 사용합니다.\n\n### 최상위 구성 요소 상호작용 다이어그램 (Top-Level Component Interaction Diagram)\n\n```mermaid\ngraph TD\n    A[사용자/운영자] -->|웹 브라우저| B[클라이언트 (Next.js)]\n    B -->|API 요청| C[Supabase API Gateway]\n    C -->|인증| D[Supabase Auth]\n    C -->|데이터 쿼리| E[Supabase PostgreSQL DB]\n    C -->|스토리지| F[Supabase Storage]\n    C -->|결제 요청| G[Stripe API]\n    C -->|알림 요청| H[알림 서비스 (카카오 알림톡/이메일)]\n    G -->|결제 결과| C\n    H -->|알림 발송| A\n```\n\n*   **사용자/운영자**는 웹 브라우저를 통해 **클라이언트(Next.js)**에 접속하여 서비스를 이용합니다.\n*   **클라이언트**는 모든 데이터 및 기능 요청을 **Supabase API Gateway**를 통해 백엔드로 전달합니다.\n*   **Supabase API Gateway**는 요청에 따라 **Supabase Auth**를 통한 인증, **Supabase PostgreSQL DB**와의 데이터 상호작용, **Supabase Storage**를 통한 파일 관리, **Stripe API**를 통한 결제 처리, 그리고 **알림 서비스**를 통한 알림 발송을 조율합니다.\n\n### 코드 구성 및 규칙 (Code Organization & Convention)\n\n**도메인 주도 조직 전략 (Domain-Driven Organization Strategy)**\n\n*   **도메인 분리**: 비즈니스 도메인(예: `예약`, `사용자`, `결제`, `관리자`)별로 코드를 분리하여 응집도를 높이고 독립적인 개발을 용이하게 합니다.\n*   **계층 기반 아키텍처**: 각 도메인 내에서 프레젠테이션, 비즈니스 로직, 데이터 접근 계층을 명확히 분리하여 관심사를 분리하고 유지보수성을 향상시킵니다.\n*   **기능 기반 모듈**: 특정 기능(예: `예약 생성`, `예약 취소`, `결제 처리`)과 관련된 모든 파일(컴포넌트, 훅, API 호출 등)을 하나의 모듈로 묶어 관련성을 명확히 합니다.\n*   **공유 컴포넌트**: 공통으로 사용되는 유틸리티 함수, 타입 정의, 재사용 가능한 UI 컴포넌트 등은 별도의 공유 모듈에 배치하여 중복을 줄입니다.\n\n**범용 파일 및 폴더 구조 (Universal File & Folder Structure)**\n\n```\n/\n├── app/                  # Next.js 앱 라우터 (페이지, 레이아웃, API 라우트)\n│   ├── (auth)/           # 인증 관련 페이지 (로그인, 회원가입 등)\n│   ├── (booking)/        # 예약 관련 페이지 (예약 달력, 예약 상세 등)\n│   ├── (admin)/          # 관리자 대시보드 페이지\n│   ├── api/              # Next.js API 라우트 (서버리스 함수)\n│   │   ├── auth/\n│   │   ├── booking/\n│   │   └── payment/\n│   ├── layout.tsx        # 전역 레이아웃\n│   └── page.tsx          # 메인 페이지\n├── components/           # 재사용 가능한 UI 컴포넌트\n│   ├── ui/               # Tailwind CSS 기반의 기본 UI 컴포넌트 (버튼, 입력 필드 등)\n│   ├── common/           # 애플리케이션 전반에 사용되는 공통 컴포넌트 (헤더, 푸터 등)\n│   └── domain/           # 특정 도메인에 특화된 컴포넌트 (예: BookingCalendar)\n├── lib/                  # 클라이언트/서버 공통 유틸리티 함수 및 헬퍼\n│   ├── supabase/         # Supabase 클라이언트 초기화 및 헬퍼\n│   ├── stripe/           # Stripe 관련 헬퍼 함수\n│   ├── utils/            # 일반 유틸리티 함수 (날짜 포맷, 가격 계산 등)\n│   └── types/            # 전역 타입 정의\n├── hooks/                # 재사용 가능한 React 훅\n├── styles/               # 전역 스타일 및 Tailwind CSS 설정\n├── public/               # 정적 자산 (이미지, 폰트 등)\n├── .env.local            # 환경 변수\n├── next.config.js        # Next.js 설정\n├── package.json          # 프로젝트 의존성\n└── tsconfig.json         # TypeScript 설정\n```\n\n### 데이터 흐름 및 통신 패턴 (Data Flow & Communication Patterns)\n\n*   **클라이언트-서버 통신**:\n    *   Next.js의 서버 컴포넌트 또는 API 라우트를 통해 Supabase API Gateway와 통신합니다.\n    *   데이터 조회는 주로 `GET` 요청을 사용하며, 데이터 생성/수정/삭제는 `POST`, `PUT`, `DELETE` 요청을 사용합니다.\n    *   Supabase SDK를 사용하여 데이터베이스 쿼리 및 인증 관련 작업을 수행합니다.\n*   **데이터베이스 상호작용**:\n    *   Supabase의 PostgreSQL 데이터베이스를 직접 쿼리하거나, Supabase에서 제공하는 ORM(Object-Relational Mapping)과 유사한 클라이언트 라이브러리를 사용하여 데이터를 조작합니다.\n    *   예약 시간 중복 방지를 위해 데이터베이스 레벨에서 `UNIQUE` 제약 조건 또는 트랜잭션을 활용합니다.\n*   **외부 서비스 통합**:\n    *   **Stripe**: 클라이언트에서 결제 정보를 입력받아 Next.js API 라우트를 통해 Stripe API로 결제 요청을 보냅니다. Stripe 웹훅을 사용하여 결제 성공/실패 알림을 받아 데이터베이스에 반영합니다.\n    *   **알림 서비스**: 예약 확정, 입장 안내, 리마인더 등의 이벤트 발생 시 Next.js API 라우트에서 알림 서비스(카카오 알림톡/이메일)의 API를 호출하여 메시지를 발송합니다.\n*   **실시간 통신**: 현재 요구사항에는 실시간 통신이 명시되어 있지 않으므로, 초기 MVP에서는 구현하지 않습니다. 향후 필요 시 Supabase Realtime 기능을 고려할 수 있습니다.\n*   **데이터 동기화**: 예약 데이터는 Supabase PostgreSQL DB에 저장되며, 모든 클라이언트 및 관리자 대시보드는 이 단일 소스를 통해 데이터를 조회하고 업데이트합니다. 예약 시간 중복 방지를 위해 DB 트랜잭션 및 제약 조건을 활용하여 데이터 일관성을 유지합니다.\n\n## 4. 성능 및 최적화 전략 (Performance & Optimization Strategy)\n\n*   **Next.js 최적화**: SSR/SSG를 활용하여 초기 로딩 속도를 최적화하고, 이미지 최적화(`next/image`), 코드 스플리팅을 통해 번들 크기를 줄여 사용자 경험을 향상시킵니다.\n*   **데이터베이스 쿼리 최적화**: Supabase PostgreSQL에서 효율적인 인덱스를 설계하고, 필요한 데이터만 조회하도록 쿼리를 최적화하여 데이터베이스 응답 시간을 단축합니다.\n*   **CDN 활용**: Vercel과 Cloudflare CDN을 통해 정적 자산(이미지, CSS, JS)을 캐싱하여 사용자에게 더 빠르게 전달하고, 서버 부하를 줄입니다.\n*   **API 응답 시간 단축**: Next.js API 라우트에서 불필요한 연산을 최소화하고, 외부 서비스(Stripe, 알림 서비스)와의 통신 지연을 고려하여 비동기 처리를 효율적으로 구현합니다.\n\n## 5. 구현 로드맵 및 마일스톤 (Implementation Roadmap & Milestones)\n\n### 1단계: 기반 구축 (MVP 구현) (Phase 1: Foundation (MVP Implementation))\n\n*   **핵심 인프라**: Vercel 배포 설정, Supabase 프로젝트 초기화 (DB, Auth), Cloudflare CDN 연동.\n*   **필수 기능 구현 우선순위**:\n    1. 예약 가능 날짜 조회 기능 (달력 기반 UI)\n    2. 시간 선택 기능 (예약 가능한 시간대 선택)\n*   **기본 보안**: Supabase Row Level Security (RLS) 설정, 환경 변수 관리. 로그인(인증) 기능은 핵심 예약/조회 기능 이후 단계적으로 적용.\n    4. 예약 현황 조회 기능 (사용자/관리자)\n    \n    이후 로그인(인증) 기능을 연동하여 예약 및 조회 액션에 인증을 추가합니다.\n    *   가격 자동 계산, 실시간 예약 가능 여부 표시는 위 기능 구현 이후에 적용\n*   **기본 보안**: Supabase Row Level Security (RLS) 설정, 환경 변수 관리.\n*   **개발 환경 설정**: 개발 환경 구성, Git 저장소 설정, 기본 CI/CD 파이프라인 구축.\n*   **예상 완료 시점**: 1-2주차\n\n### 2단계: 기능 강화 (Phase 2: Feature Enhancement)\n\n*   **고급 기능**:\n    *   사용자: Stripe 결제 연동, 결제 완료 후 예약 상태 변경 (\"confirmed\"), 예약 내역 확인 페이지 (링크 기반), 예약 취소 기능 (환불 정책 적용).\n    *   관리자: 예약 수동 등록/수정 기능.\n*   **성능 최적화**: Next.js 이미지 최적화, Supabase 쿼리 최적화.\n*   **강화된 보안**: 결제 정보 암호화 (Stripe 처리), 민감 데이터 접근 제어 강화.\n*   **모니터링 구현**: Vercel 및 Supabase 기본 로깅 및 모니터링 설정.\n*   **예상 완료 시점**: 3-5주차\n\n### 3단계: 확장 및 최적화 (Phase 3: Scaling & Optimization)\n\n*   **확장성 구현**:\n    *   사용자: QR 또는 도어락 비밀번호 자동 발송 연동 (외부 API 연동), 입장 시각 10분 전 리마인드 알림 발송.\n    *   관리자: 운영 시간, 이용 요금, 취소 정책 설정 기능.\n*   **고급 통합**: 카카오 알림톡 또는 이메일 서비스 연동.\n*   **엔터프라이즈 기능**: 동시 예약 방지 로직 강화 (DB 트랜잭션, 락), 노쇼 방지 로직 (선결제, 리마인더).\n*   **규정 준수 및 감사**: 개인정보 처리 방침 및 환불 정책 명시, 관련 법규 준수 검토.\n*   **예상 완료 시점**: 6-8주차\n\n## 6. 위험 평가 및 완화 전략 (Risk Assessment & Mitigation Strategies)\n\n### 기술적 위험 분석 (Technical Risk Analysis)\n\n*   **기술 위험**:\n    *   **잠재적 문제**: Supabase의 특정 기능(예: 복잡한 쿼리, 웹훅 처리)이 요구사항을 완전히 충족하지 못할 수 있습니다.\n    *   **완화 전략**: Supabase 문서 및 커뮤니티를 적극 활용하고, 필요한 경우 PostgreSQL의 원시 쿼리 또는 Supabase Edge Functions를 사용하여 커스텀 로직을 구현합니다.\n*   **성능 위험**:\n    *   **잠재적 문제**: 동시 접속자 증가 시 예약 시스템의 응답 속도가 저하될 수 있습니다.\n    *   **완화 전략**: 데이터베이스 인덱스 최적화, 캐싱 전략 도입 (Next.js 캐싱, Cloudflare CDN), Supabase의 성능 모니터링을 통해 병목 현상을 조기에 식별하고 대응합니다.\n*   **보안 위험**:\n    *   **잠재적 문제**: 고객 정보 및 결제 정보 유출, 무단 접근.\n    *   **완화 전략**: Supabase RLS를 통한 데이터 접근 제어, Stripe를 통한 결제 정보 직접 처리(서버에 저장하지 않음), 모든 통신에 HTTPS 적용, 정기적인 보안 취약점 점검.\n*   **통합 위험**:\n    *   **잠재적 문제**: Stripe, 카카오 알림톡/이메일 서비스 등 외부 API 연동 시 예상치 못한 오류 또는 서비스 중단.\n    *   **완화 전략**: 외부 API 연동 시 오류 처리 및 재시도 로직 구현, 폴백(fallback) 메커니즘 마련 (예: 알림톡 실패 시 이메일 발송), 외부 서비스의 상태 모니터링.\n\n### 프로젝트 전달 위험 (Project Delivery Risks)\n\n*   **일정 위험**:\n    *   **잠재적 문제**: 개발 일정 지연으로 인한 출시일 준수 어려움.\n    *   **완화 전략**: 애자일 방법론을 적용하여 스프린트 단위로 개발하고, 주간 진행 상황을 공유하며, 우선순위가 낮은 기능은 다음 단계로 이월하여 MVP를 먼저 출시합니다.\n*   **자원 위험**:\n    *   **잠재적 문제**: 개발 인력 부족 또는 특정 기술 전문성 부족.\n    *   **완화 전략**: Supabase와 Next.js 등 검증된 기술 스택을 사용하여 개발 복잡도를 낮추고, 필요한 경우 외부 전문가의 자문을 구하거나 오픈 소스 커뮤니티의 도움을 받습니다.\n*   **품질 위험**:\n    *   **잠재적 문제**: 버그 발생, 기능 오작동, 사용자 경험 저하.\n    *   **완화 전략**: 단위 테스트 및 통합 테스트를 통해 코드 품질을 확보하고, 사용자 시나리오 기반의 QA를 철저히 수행하며, 출시 전 베타 테스트를 통해 실제 사용자 피드백을 반영합니다.\n*   **배포 위험**:\n    *   **잠재적 문제**: 프로덕션 환경 배포 시 예상치 못한 문제 발생.\n    *   **완화 전략**: 개발/스테이징/프로덕션 환경을 분리하고, Vercel의 자동 배포 기능을 활용하여 배포 프로세스를 간소화하며, 롤백 계획을 수립하여 문제 발생 시 신속하게 이전 버전으로 복구할 수 있도록 합니다.",
      "writedAt": "2025-07-23T07:55:12.876Z"
    },
    {
      "type": "clean-code",
      "content": "\n# Clean Code Guidelines\n\nYou are an expert software engineer focused on writing clean, maintainable code. Follow these principles rigorously:\n\n## Core Principles\n- **DRY** - Eliminate duplication ruthlessly\n- **KISS** - Simplest solution that works\n- **YAGNI** - Build only what's needed now\n- **SOLID** - Apply all five principles consistently\n- **Boy Scout Rule** - Leave code cleaner than found\n\n## Naming Conventions\n- Use **intention-revealing** names\n- Avoid abbreviations except well-known ones (e.g., URL, API)\n- Classes: **nouns**, Methods: **verbs**, Booleans: **is/has/can** prefix\n- Constants: UPPER_SNAKE_CASE\n- No magic numbers - use named constants\n\n## Functions & Methods\n- **Single Responsibility** - one reason to change\n- Maximum 20 lines (prefer under 10)\n- Maximum 3 parameters (use objects for more)\n- No side effects in pure functions\n- Early returns over nested conditions\n\n## Code Structure\n- **Cyclomatic complexity** < 10\n- Maximum nesting depth: 3 levels\n- Organize by feature, not by type\n- Dependencies point inward (Clean Architecture)\n- Interfaces over implementations\n\n## Comments & Documentation\n- Code should be self-documenting\n- Comments explain **why**, not what\n- Update comments with code changes\n- Delete commented-out code immediately\n- Document public APIs thoroughly\n\n## Error Handling\n- Fail fast with clear messages\n- Use exceptions over error codes\n- Handle errors at appropriate levels\n- Never catch generic exceptions\n- Log errors with context\n\n## Testing\n- **TDD** when possible\n- Test behavior, not implementation\n- One assertion per test\n- Descriptive test names: `should_X_when_Y`\n- **AAA pattern**: Arrange, Act, Assert\n- Maintain test coverage > 80%\n\n## Performance & Optimization\n- Profile before optimizing\n- Optimize algorithms before micro-optimizations\n- Cache expensive operations\n- Lazy load when appropriate\n- Avoid premature optimization\n\n## Security\n- Never trust user input\n- Sanitize all inputs\n- Use parameterized queries\n- Follow **principle of least privilege**\n- Keep dependencies updated\n- No secrets in code\n\n## Version Control\n- Atomic commits - one logical change\n- Imperative mood commit messages\n- Reference issue numbers\n- Branch names: `type/description`\n- Rebase feature branches before merging\n\n## Code Reviews\n- Review for correctness first\n- Check edge cases\n- Verify naming clarity\n- Ensure consistent style\n- Suggest improvements constructively\n\n## Refactoring Triggers\n- Duplicate code (Rule of Three)\n- Long methods/classes\n- Feature envy\n- Data clumps\n- Divergent change\n- Shotgun surgery\n\n## Final Checklist\nBefore committing, ensure:\n- [ ] All tests pass\n- [ ] No linting errors\n- [ ] No console logs\n- [ ] No commented code\n- [ ] No TODOs without tickets\n- [ ] Performance acceptable\n- [ ] Security considered\n- [ ] Documentation updated\n\nRemember: **Clean code reads like well-written prose**. Optimize for readability and maintainability over cleverness.\n",
      "writedAt": "2025-07-23T07:55:12.876Z"
    }
  ]
}